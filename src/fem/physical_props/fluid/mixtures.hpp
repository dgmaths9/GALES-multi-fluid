#ifndef GALES_MIXTURES_HPP
#define GALES_MIXTURES_HPP




#include "base_mixture.hpp"
#include "chemicals.hpp"
#include "non_newtonian.hpp"
#include "GiordanoEtAlViscosityModel.hpp"



namespace GALES {




    /**
         This class defines chemical as one mixture component.
         This makes sense if we have to make a whole mixture where one component is already a mixture and another is a chemical.
         In this case it becomes necessary to project ch as a mixture.
    */

    class ch_as_mix : public base_mixture
    {
    public:

        ch_as_mix(const std::vector<std::shared_ptr<base_chemical>>& chemical_ptrs)
        {
            chemical_ptrs_ = chemical_ptrs;
        }

       //-------------------------------------------------------------------------------------------------------------------------------------        
       /// Deleting the copy and move constructors - no duplication/transfer in anyway
       ch_as_mix(const ch_as_mix&) = delete;               //copy constructor
       ch_as_mix& operator=(const ch_as_mix&) = delete;    //copy assignment operator
       ch_as_mix(ch_as_mix&&) = delete;                    //move constructor  
       ch_as_mix& operator=(ch_as_mix&&) = delete;         //move assignment operator 
       //-------------------------------------------------------------------------------------------------------------------------------------

        void properties(double p, double T, double strain_rate) final
        {
            chemical_ptrs_[0]->properties(p,T,strain_rate);
            rho_ = chemical_ptrs_[0]->rho_;
            mu_ = chemical_ptrs_[0]->mu_;
            kappa_ = chemical_ptrs_[0]->kappa_;
            sound_speed_ = chemical_ptrs_[0]->sound_speed_;
            cv_ = chemical_ptrs_[0]->cv_;
            cp_ = chemical_ptrs_[0]->cp_;
            alpha_ = chemical_ptrs_[0]->alpha_;
            beta_ = chemical_ptrs_[0]->beta_;
        }

    };









    /**
         This class defines custom mixture as one mixture component.
    */

    class custom_mixture : public base_mixture
    {
    public:

       custom_mixture(double rho, double mu, double cp, double kappa, double alpha, double beta)
       {
         rho_ = rho;
         mu_ = mu;
         cp_ = cp;
         alpha_ = alpha;
         beta_ = beta;
         kappa_ = kappa;
         if(beta_==0.0) sound_speed_ = 1.e20;   // We set very high value for fully incompressible fluid and its flow(in reality it should be infinite)
         else sound_speed_ = 1.0/sqrt(rho_*beta_); 
       }
                    
       //-------------------------------------------------------------------------------------------------------------------------------------        
       /// Deleting the copy and move constructors - no duplication/transfer in anyway
       custom_mixture(const custom_mixture&) = delete;               //copy constructor
       custom_mixture& operator=(const custom_mixture&) = delete;    //copy assignment operator
       custom_mixture(custom_mixture&&) = delete;                    //move constructor  
       custom_mixture& operator=(custom_mixture&&) = delete;         //move assignment operator 
       //-------------------------------------------------------------------------------------------------------------------------------------

       void properties(double p, double T, double strain_rate) final
       {
         if(beta_==0.0)  cv_ = cp_;	// this is true for fully incompressible fluid and its flow
         else cv_ = cp_ - T*alpha_*alpha_/(rho_*beta_);
       }
    };









    /**
         magma mixture class in GALES
         magma mixture is hard coded for five chemicals - melt, h2o(l), co2(l), h2o(g), co2(g)  
         depending on pressure and temperature, wf of h2o(l) and co2(l) in the liquid phase is read from a lookuptable 
         lookuptable files are already generated by running solwcad in the {simulation}/input/lookuptable directory
         the effects of gas and crystals on magma density and viscosity acan be chosen by defining model name
    */
    class magma_mixture : public base_mixture
    {
        using vec = boost::numeric::ublas::vector<double>;
        using mat = boost::numeric::ublas::matrix<double>;

    public:

        magma_mixture
        (
          const std::string& name,                        /// name of the magma type
          const std::vector<double>& oxide_wf,            /// vector of melt oxide fraction
          double melt_kappa,                              /// kappa of melt
          double h2o_wf,                                  /// total h2o wf (l + g)
          double h2o_l_cp,                                /// cp of h2o (l)
          double h2o_l_kappa,                             /// kappa of h2o (l)
          double co2_wf,                                  /// total co2 wf (l + g)
          double co2_l_cp,                                /// cp of co2 (l)
          double co2_l_kappa,                             /// kappa of co2 (l)
          const std::string& gas_on_mu,                   /// model name for effect of gas on mu
          const std::string& crystal_on_mu,               /// model name for effect of crystals on mu
          double crystal_vf,                              /// crystal volume fraction
          double crystal_rho                              /// crystal density
        )
        :
            gas_on_mu_(gas_on_mu),
            crystal_on_mu_(crystal_on_mu),
            crystal_vf_(crystal_vf),
            crystal_rho_(crystal_rho)
            {
                wf_comp_[1] = h2o_wf;                               ///   wt of h2O(l+g)/ wt of magma
                wf_comp_[2] = co2_wf;                               ///   wt of CO2(l+g)/ wt of magma
                wf_comp_[0] = 1.0 - wf_comp_[1] - wf_comp_[2];      ///   wt of melt/ wt of magma

                nb_comp_ = 5;                                       /// melt, h2o(l), co2(l), h2o(g), co2(g)
                chemical_ptrs_.resize(nb_comp_);
                wf_.resize(nb_comp_);
                vf_.resize(nb_comp_);

                chemical_ptrs_[0] = std::make_shared<melt>(oxide_wf, melt_kappa);                                  /// melt
                chemical_ptrs_[1] = std::make_shared<dissolved_volatiles>("H2O", h2o_l_cp, h2o_l_kappa);           /// h2o(l)
                chemical_ptrs_[2] = std::make_shared<dissolved_volatiles>("CO2", co2_l_cp, co2_l_kappa);           /// co2(l)
                chemical_ptrs_[3] = std::make_shared<ideal_gas>("H2O");                                            /// h2o(g)
                chemical_ptrs_[4] = std::make_shared<ideal_gas>("CO2");                                            /// co2(g)

                lookup_table(name);

                viscosity_model_.set(chemical_ptrs_[0]->oxides_wf(), chemical_ptrs_[0]->oxides_molar_mass());
            }



           //-------------------------------------------------------------------------------------------------------------------------------------        
           /// Deleting the copy and move constructors - no duplication/transfer in anyway
           magma_mixture(const magma_mixture&) = delete;               //copy constructor
           magma_mixture& operator=(const magma_mixture&) = delete;    //copy assignment operator
           magma_mixture(magma_mixture&&) = delete;                    //move constructor  
           magma_mixture& operator=(magma_mixture&&) = delete;         //move assignment operator 
           //-------------------------------------------------------------------------------------------------------------------------------------


            void properties(double p, double T, double strain_rate) final
            {
                clear();

                submix_of_comp(p, T, strain_rate);
                mu_ = viscosity_model_.computeViscosity(T, wf_comp_in_liquid_phase_[1], wf_comp_in_liquid_phase_[2]);

                if(gas_on_mu_ == "Ishii_Zuber")  mu_ = Ishii_Zuber(vf_ph_[g_], mu_);                    ///gas contribution
                else if(gas_on_mu_ == "Pal_2003") mu_ = Pal_2003(vf_ph_[g_], mu_, strain_rate);

                if(crystal_on_mu_ == "Einstein_Roscoe") mu_ = Einstein_Roscoe(1.0, crystal_vf_, mu_);   ///crystal contribution
                else if(crystal_on_mu_ == "Caricchi") mu_ = Caricchi(crystal_vf_, mu_, strain_rate);
            }




        private:



            /// This computes the sub mixture density and volume fractions.
            void submix_of_comp(double p, double T, double strain_rate)
            {
                if(T_vec_ == nullptr)
                {
                    wf_comp_in_liquid_phase_[1] = interpolation(p, *p_vec_, *wf_l_h2o_vec_);         ///   wt of h2O(l)/ wt of l
                    wf_comp_in_liquid_phase_[2] = interpolation(p, *p_vec_, *wf_l_co2_vec_);         ///   wt of CO2(l)/ wt of l
                }
                else
                {
                    wf_comp_in_liquid_phase_[1] = interpolation(T, p, *T_vec_, *p_vec_, *wf_l_h2o_mat_);         ///   wt of h2O(l)/ wt of l
                    wf_comp_in_liquid_phase_[2] = interpolation(T, p, *T_vec_, *p_vec_, *wf_l_co2_mat_);         ///   wt of CO2(l)/ wt of l
                }
                wf_comp_in_liquid_phase_[0] = 1.0 - wf_comp_in_liquid_phase_[1] - wf_comp_in_liquid_phase_[2];	                          ///   wt of melt(l)/ wt of l



                ///-----------wf of H2O and CO2 in l/g phase-------------------------
                wf_[0] = wf_comp_[0]; 	                               ///   wt of melt(l)/ wt of magma;  wt of melt(l) = wt of melt

                wf_ph_[l_] = wf_[0]/wf_comp_in_liquid_phase_[0];       ///  wt of l/ wt of magma
                wf_ph_[g_] = 1.0-wf_ph_[l_];		               ///  wt of g/ wt of magma

                wf_[1] = wf_comp_in_liquid_phase_[1]*wf_ph_[l_];       ///  wt of h2O(l)/ wt of magma
                wf_[2] = wf_comp_in_liquid_phase_[2]*wf_ph_[l_];       ///  wt of CO2(l)/ wt of magma
                wf_[3] = wf_comp_[1]- wf_[1];	                       ///  wt of h2O(g)/ wt of magma
                wf_[4] = wf_comp_[2]- wf_[2];	                       ///  wt of CO2(g)/ wt of magma


                ///------------------density--------------------------------------
                rho_ = 0.0;
                for (int c=0; c<nb_comp_; c++)
                {
                    chemical_ptrs_[c]->properties(p,T,strain_rate);
                    rho_ += wf_[c]/chemical_ptrs_[c]->rho_;
                }
                rho_ = 1./rho_;
                rho_ = (1.0-crystal_vf_)*rho_ + crystal_vf_*crystal_rho_;      ///crystal contribution to density;


                ///-----------------rest of the properties------------------------------
                for (int c=0; c<nb_comp_; c++)
                {
                    cp_ += wf_[c]*chemical_ptrs_[c]->cp_;
                    cv_ += wf_[c]*chemical_ptrs_[c]->cv_;
                    alpha_ += wf_[c]*chemical_ptrs_[c]->alpha_*rho_/chemical_ptrs_[c]->rho_;
                    beta_ += wf_[c]*chemical_ptrs_[c]->beta_*rho_/chemical_ptrs_[c]->rho_;
                    kappa_ += wf_[c]*chemical_ptrs_[c]->kappa_;
                    chemical_diffusivity_ += wf_[c]*chemical_ptrs_[c]->chemical_diffusivity_;

                    sound_speed_ += wf_[c]/(pow(chemical_ptrs_[c]->rho_,2) * pow(chemical_ptrs_[c]->sound_speed_,2));
                }

                sound_speed_ = sqrt(1./sound_speed_);
                sound_speed_ /= rho_;


                ///-------------------vf of chemicals--------------------
                for (int c=0; c<nb_comp_; c++)
                vf_[c] = wf_[c]*rho_/chemical_ptrs_[c]->rho_;


                ///-------------------vf of phases--------------------             /// index: melt=0,  h2O(l)=1,  CO2(l)=2,  h2O(g)=3,  CO2(g)=4
                vf_ph_[l_] = vf_[0] + vf_[1] + vf_[2];
                vf_ph_[g_] = vf_[3] + vf_[4];
            }





            ///---------pal 2003 4th model (eq 21) for bubble bearing magma (broad Ca range with deformable bubbles)---------------------------
            double Pal_2003(double vf_g, double mu, double shear_rate)
            {
                if(shear_rate < std::numeric_limits<double>::epsilon())  return mu;
                else
                {
                    const double surface_tension = 0.36;
                    const double bubble_number_density = 1.e11;
                    const double max_volume_packing = 0.9999;
                    const double bubble_radius = cbrt(3.0/(4*3.142*bubble_number_density));
                    const double capillary_number = bubble_radius*mu*shear_rate/surface_tension;

                    const double a = 2.4*pow(capillary_number,2);
                    const double T = pow(1.0-a, -0.8) * pow(1.0-vf_g/max_volume_packing, -max_volume_packing);
                    double x = 1.e-5;
                    double F, F_prime;
                    do
                    {
                        F = pow(x,5)/pow(1.0-a*x*x,4) - pow(T,5);
                        F_prime = 5*pow(x,4)/pow(1.0-a*x*x,4) + 8*a*pow(x,6)/pow(1.0-a*x*x,5);
                        x -= F/F_prime;
                    }
                    while(F < 1.e-9);

                    return mu*x;
                }
            }




            ///--------- Ishii_Zuber (1979) non deformable, spherical bubbles bearing magma (Ca<<1) ---------------------------
            double Ishii_Zuber(double vf_g, double mu)
            {
                return mu/(1.0-vf_g);
            }





            ///---------Einstein-Roscoe (1952) suspensions of rigid spheres objects in magma -----------------------------------
            double Einstein_Roscoe(double b, double content, double mu)
            {
                return mu*pow(1.0-b*content, -2.5);
            }




            ///---------Caricchi (2007) eq(3) crystal-bearing magma---------------------------------------------------------
            double Caricchi(double solid_packing_fraction, double mu, double Strain_Rate)
            {
                double strain_rate = Strain_Rate;
                if(strain_rate < std::numeric_limits<double>::epsilon())  
                   strain_rate = 1.e-6;

                const double phi_max = 0.066499*tanh(0.913424*log10(strain_rate) + 3.850623) + 0.591806;
                const double delta = -6.301095*tanh(0.818496*log10(strain_rate) + 2.86) + 7.462405;
                const double alpha = -0.000378*tanh(1.148101*log10(strain_rate) + 3.92) + 0.999572;
                const double gamma = 3.987815*tanh(0.8908*log10(strain_rate) + 3.24) + 5.099645;                    
                const double num = 1.0 + pow(solid_packing_fraction/phi_max, delta);                    
                const double x = sqrt(3.142)*solid_packing_fraction/(2*alpha*phi_max)*(1.0 + pow(solid_packing_fraction/phi_max, gamma));
                const double den = pow(1.0-alpha*erf(x), 2.5*phi_max);
                double mu_r = num/den;
                return mu*mu_r;
            }



            
            /// This function interpolate p on equispaced vectors (y and pressure_table)
            /// y = wf_l_h2o_table   or  y = wf_l_co2_table
            /// consider p is along x-axis and y along y-axis

            double interpolation(const double p, const vec& pressure_table, const vec& y)
            {
                const double delta_p(pressure_table[1]-pressure_table[0]);
                const std::size_t p_indx = (int)floor((p-pressure_table[0])/delta_p);

                if(p_indx >= pressure_table.size() || p_indx+1 >= pressure_table.size())
                {
                    std::cerr<<"\n p = "<<p<<"\n\n";
                    Error("p_index goes out of the vector scope");                    
                }

                const double slope = (y[p_indx+1]-y[p_indx])/delta_p;
                return y[p_indx] + slope*(p-pressure_table[p_indx]);
            }





            /**
               This is bilinear interpolation of (T,p) on equispaced vectors(temperature_table, pressure_table) and matrix m
               m = wf_l_h2o_table   or m = wf_l_co2_table
               Format of m as well as bilinear interpolation is as follows:
                              p
                           --------->
                     _____p1__________p2____
                  |  |
                  |  T1    .           .
                T |  |
                  |  |        .(T,p)
                  v  |
                    T2    .           .
                     |
                     |

                mind the order (p is column-wise, T is row-wise)
            */   


            template<typename vec, typename mat>
            double interpolation(const double T, const double p, const vec& temperature_table, const vec& pressure_table, const mat& m)
            {
                const double delta_p(std::abs(pressure_table[1]-pressure_table[0]));
                const std::size_t p_c_indx = (int)floor(std::abs(p-pressure_table[0])/delta_p);     

                const double delta_T(std::abs(temperature_table[1] - temperature_table[0]));
                const std::size_t T_r_indx = (int)floor(std::abs(T - temperature_table[0])/delta_T);      

                if(p_c_indx >= pressure_table.size() || p_c_indx+1 >= pressure_table.size())
                {
                    std::cerr<<"\n p = "<<p<<"\n\n";
                    Error("p_c_index goes out of the vector scope");                                        
                }

                if(T_r_indx >= temperature_table.size() || T_r_indx+1 >= temperature_table.size())
                {
                    std::cerr<<"\n T = "<<T<<"\n\n";
                    Error("T_r_index goes out of the vector scope");                                        
                }

                const double p1 = pressure_table[p_c_indx];         
                const double p2 = pressure_table[p_c_indx+1];       
                const double T1 = temperature_table[T_r_indx];      
                const double T2 = temperature_table[T_r_indx+1];    

                double mean = (T2-T)*(p2-p)*m(T_r_indx, p_c_indx) + (T2-T)*(p-p1)*m(T_r_indx, p_c_indx+1)
                + (T-T1)*(p2-p)*m(T_r_indx+1, p_c_indx) + (T-T1)*(p-p1)*m(T_r_indx+1, p_c_indx+1);

                mean /= delta_T*delta_p;        
                return mean;
            }



            /// read lookup table
            void lookup_table(std::string s)
            {
                std::ifstream if_p("input/lookuptable/pressure.txt");
                if(!if_p.is_open())
                {
                   Error("unable to open and read   'input/lookuptable/pressure.txt' ");                                          
                }
                int size_p;
                if_p>>size_p;
                p_vec_ = std::make_unique<vec>(size_p);
                for (int i=0; i<size_p; i++)
                  if_p >> (*p_vec_)[i];
                if_p.close();

                std::string s1;
                std::ifstream if_T("input/lookuptable/temperature.txt");
                if(if_T.is_open())
                {
                    int size_T;
                    if_T>>size_T;
                    T_vec_ = std::make_unique<vec>(size_T);
                    for (int i=0; i<size_T; i++)
                      if_T >> (*T_vec_)[i];
                    if_T.close();
                    
                    s1 = "input/lookuptable/wf_l_h2o_onliq_" + s + ".txt";
                    std::ifstream if_wf_l_h2o(s1);
                    if(!if_wf_l_h2o.is_open())
                    {
                       Error("unable to open and read   'input/lookuptable/wf_l_h2o_onliq_' ");                                                                     
                    }
                    wf_l_h2o_mat_ = std::make_unique<mat>(size_T,size_p);
                    for (int i=0; i<size_T; i++)
                      for (int j=0; j<size_p; j++)
                        if_wf_l_h2o >> (*wf_l_h2o_mat_)(i,j);
                    if_wf_l_h2o.close();

                    s1 = "input/lookuptable/wf_l_co2_onliq_" + s + ".txt";
                    std::ifstream if_wf_l_co2(s1);
                    if(!if_wf_l_co2.is_open())
                    {
                       Error("unable to open and read   'input/lookuptable/wf_l_co2_onliq_' ");                                                                                            
                    }
                    wf_l_co2_mat_ = std::make_unique<mat>(size_T,size_p);
                    for (int i=0; i<size_T; i++)
                      for (int j=0; j<size_p; j++)
                        if_wf_l_co2 >> (*wf_l_co2_mat_)(i,j);
                    if_wf_l_co2.close();                    
                }
                else
                {
                    s1 = "input/lookuptable/wf_l_h2o_onliq_" + s + ".txt";
                    std::ifstream if_wf_l_h2o(s1);
                    if(!if_wf_l_h2o.is_open())
                    {
                       Error("unable to open and read   'input/lookuptable/wf_l_h2o_onliq_' ");                                                                                            
                    }
                    wf_l_h2o_vec_ = std::make_unique<vec>(size_p);
                    for (int i=0; i<size_p; i++)
                      if_wf_l_h2o >> (*wf_l_h2o_vec_)[i];
                    if_wf_l_h2o.close();

                    s1 = "input/lookuptable/wf_l_co2_onliq_" + s + ".txt";
                    std::ifstream if_wf_l_co2(s1);
                    if(!if_wf_l_co2.is_open())
                    {
                       Error("unable to open and read   'input/lookuptable/wf_l_co2_onliq_' ");                                                                                            
                    }
                    wf_l_co2_vec_ = std::make_unique<vec>(size_p);
                    for (int i=0; i<size_p; i++)
                      if_wf_l_co2 >> (*wf_l_co2_vec_)[i];
                    if_wf_l_co2.close();                
                }
            }




            std::unique_ptr<vec> p_vec_ = nullptr; 
            std::unique_ptr<vec> T_vec_ = nullptr;
            std::unique_ptr<vec> wf_l_h2o_vec_ = nullptr; 
            std::unique_ptr<vec> wf_l_co2_vec_ = nullptr;
            std::unique_ptr<mat> wf_l_h2o_mat_ = nullptr; 
            std::unique_ptr<mat> wf_l_co2_mat_ = nullptr;
            GiordanoEtAlViscosityModel viscosity_model_;

            std::string gas_on_mu_, crystal_on_mu_;
            double crystal_vf_ = 0.0;
            double crystal_rho_ = 0.0;

            vec wf_comp_ = vec(3, 0.0);                           /// index: melt=0  h2O=1,  CO2=2
            vec wf_comp_in_liquid_phase_ = vec(3, 0.0);           /// index: melt=0  h2O=1,  CO2=2
        };


    }

    #endif
